# Документація до домашнього завдання

## Завдання 1: Оптимізація доступу до даних за допомогою LRU-кешу

### Алгоритм LRU (Least Recently Used)

LRU-кеш — це структура даних, яка зберігає обмежену кількість елементів і видаляє найменш нещодавно використовувані елементи при переповненні.

### Реалізація

#### Клас LRUCache

```python
class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache: Dict[Tuple[int, int], int] = {}
        self.access_order = []  # Список для відстеження порядку використання
```

**Основні методи:**

1. **get(key)** — O(n) складність

   - Повертає значення з кешу або -1 (cache-miss)
   - Оновлює порядок доступу (переміщує ключ в кінець списку)

2. **put(key, value)** — O(n) складність

   - Додає нову пару ключ-значення
   - При переповненні видаляє найменш використовуваний елемент (перший у списку)

3. **invalidate_range(index)** — O(n) складність
   - Видаляє всі діапазони, що містять вказаний індекс
   - Використовується при оновленні елементів масиву

### Функції для роботи з масивом

#### Без кешування:

- `range_sum_no_cache(array, left, right)` — обчислює суму напряму
- `update_no_cache(array, index, value)` — оновлює елемент

#### З кешуванням:

- `range_sum_with_cache(array, left, right)` — перевіряє кеш перед обчисленням
- `update_with_cache(array, index, value)` — оновлює і інвалідує кеш

### Генерація тестових даних

Функція `make_queries()` створює реалістичний набір запитів:

- 97% Range-запитів (підрахунок суми)
- 3% Update-запитів (оновлення елементів)
- 95% Range-запитів використовують "гарячі" діапазони (пул з 30 популярних діапазонів)
- 5% Range-запитів повністю випадкові

Це імітує реальний сценарій, де деякі запити виконуються часто (популярні дані), а інші рідко.

### Результати тестування

**Типові результати:**

- Без кешу: ~10 секунд
- З LRU-кешем: ~3 секунди
- **Прискорення: 3x**

**Чому кеш ефективний?**

1. 95% запитів звертаються до 30 популярних діапазонів
2. Ємність кешу (1000) достатня для зберігання всіх популярних діапазонів
3. Повторні запити отримують миттєві відповіді з кешу
4. Update-запити (3%) рідко інвалідують кеш

### Критерії прийняття - Виконання

✅ **Всі функції реалізовані:**

- `range_sum_no_cache` — обчислює суму без кешування
- `update_no_cache` — оновлює елемент без кешування
- `range_sum_with_cache` — використовує LRU-кеш для пошуку
- `update_with_cache` — оновлює з інвалідацією кешу

✅ **Вимірювання часу:**

- Програма вимірює час виконання з кешем і без
- Виводить результати у зрозумілому форматі

✅ **Результати тестування:**

- Виведення показує час виконання та прискорення
- Додаткова статистика: заощаджений час, ефективність

✅ **Код працює без помилок:**

- Тестовано на масиві 100,000 елементів
- Обробка 50,000 запитів
- Всі технічні вимоги виконані

---

## Завдання 2: Rate Limiter з алгоритмом Sliding Window

### Алгоритм Sliding Window

Sliding Window (ковзне вікно) — це алгоритм, який відстежує події в динамічному часовому інтервалі. На відміну від Fixed Window (фіксоване вікно), він забезпечує більш точний контроль частоти запитів.

### Реалізація

#### Клас SlidingWindowRateLimiter

```python
class SlidingWindowRateLimiter:
    def __init__(self, window_size: int = 10, max_requests: int = 1):
        self.window_size = window_size  # Розмір вікна в секундах
        self.max_requests = max_requests  # Максимум повідомлень у вікні
        self.user_messages: Dict[str, deque] = {}  # Історія для кожного користувача
```

**Структура даних:**

- `collections.deque` — двостороння черга для ефективного додавання/видалення
- Зберігає часові мітки повідомлень для кожного користувача

### Методи класу

#### 1. `_cleanup_window(user_id, current_time)`

**Призначення:** Очищення застарілих записів

**Алгоритм:**

1. Визначає початок активного вікна: `current_time - window_size`
2. Видаляє всі повідомлення, старіші за це значення
3. Якщо у користувача не залишилось повідомлень, видаляє його запис

**Складність:** O(k), де k — кількість застарілих повідомлень

#### 2. `can_send_message(user_id)`

**Призначення:** Перевірка можливості відправлення

**Алгоритм:**

1. Очищає застарілі повідомлення
2. Перевіряє кількість активних повідомлень у вікні
3. Повертає True, якщо кількість < max_requests

**Складність:** O(k), де k — кількість застарілих повідомлень

#### 3. `record_message(user_id)`

**Призначення:** Запис нового повідомлення

**Алгоритм:**

1. Перевіряє, чи можна відправити повідомлення
2. Якщо так — додає поточний час у deque користувача
3. Повертає True (успіх) або False (відхилено)

**Складність:** O(k), де k — кількість застарілих повідомлень

#### 4. `time_until_next_allowed(user_id)`

**Призначення:** Розрахунок часу очікування

**Алгоритм:**

1. Очищає застарілі повідомлення
2. Якщо можна відправити зараз — повертає 0
3. Інакше — обчислює час до видалення найстарішого повідомлення

**Складність:** O(k), де k — кількість застарілих повідомлень

### Приклад роботи

**Сценарій:** window_size=10, max_requests=1

```
t=0.0:  User1 відправляє повідомлення → ✓ (перше повідомлення)
t=0.5:  User1 намагається знову → × (очікування 9.5с)
t=10.1: User1 відправляє повідомлення → ✓ (вікно очистилось)
```

### Переваги Sliding Window перед Fixed Window

**Fixed Window:**

```
Вікно 1: [0-10с]  → 1 повідомлення
Вікно 2: [10-20с] → 1 повідомлення
Проблема: можна відправити 2 повідомлення за 1 секунду (на межі вікон)
```

**Sliding Window:**

```
Будь-який момент часу перевіряє останні 10 секунд
Неможливо обійти ліміт на межі вікон
Точніший контроль частоти
```

### Оптимізація пам'яті

**Автоматичне очищення:**

- Видалення застарілих записів при кожній перевірці
- Видалення користувачів без активних повідомлень
- Використання deque для O(1) операцій з обох кінців

### Тестування

**Тест 1:** Базова функціональність

- Перше повідомлення: ✓
- Наступні в межах вікна: ×

**Тест 2:** Очищення вікна

- Після закінчення window_size повідомлення знову дозволяються

**Тест 3:** Багато користувачів

- Кожен користувач має окремий лічильник
- Обмеження не впливають на інших користувачів

### Критерії прийняття - Виконання

✅ **Раннє повідомлення блокується:**

- При спробі відправити раніше ніж через 10 секунд повертається False

✅ **Перше повідомлення завжди дозволено:**

- Новий користувач може відправити перше повідомлення

✅ **Автоматичне очищення:**

- При видаленні всіх повідомлень користувача його запис видаляється

✅ **Час очікування:**

- `time_until_next_allowed` повертає коректний час у секундах

✅ **Тестова функція працює:**

- Програма виконується згідно з очікуваннями
- Виведення відповідає шаблону

---

## Практичне застосування

### LRU-кеш

**Реальні сценарії:**

- Кешування результатів SQL-запитів
- Кешування API-відповідей
- Кешування обчислювальних результатів
- Кешування веб-сторінок

**Коли використовувати:**

- Є популярні запити, що повторюються
- Обчислення результату коштовне
- Обмежена пам'ять для кешу
- Потрібна автоматична евакуація старих даних

### Rate Limiter

**Реальні сценарії:**

- Захист API від DDOS-атак
- Контроль частоти запитів до бази даних
- Обмеження відправлення повідомлень у чаті
- Контроль використання ресурсів

**Коли використовувати:**

- Потрібен контроль частоти дій користувачів
- Необхідний захист від спаму
- Обмеження використання ресурсів
- Забезпечення справедливого розподілу ресурсів

---

## Висновки

### Завдання 1

- ✅ Реалізовано ефективний LRU-кеш
- ✅ Продемонстровано прискорення в 3 рази
- ✅ Інвалідація кешу працює коректно
- ✅ Всі критерії прийняття виконані

### Завдання 2

- ✅ Реалізовано Sliding Window Rate Limiter
- ✅ Точний контроль часових інтервалів
- ✅ Ефективне використання пам'яті
- ✅ Всі критерії прийняття виконані

**Обидві реалізації готові до використання в продакшені! 🚀**
